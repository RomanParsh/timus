## Основная модель 

- Входные данные дают неориентированный граф: n вершин (поселений) и m рёбер (дороги). Каждое ребро задаётся двумя числами `a b` — между вершинами `a` и `b` есть двунаправленная связь.
- В коде граф хранится как список смежности `adj` длины `n`, где `adj[u]` — список соседей вершины `u` (с учётом сдвига индексов: входные вершины переводятся в 0‑индексацию).
- Также в условии заданы три специальные вершины: `s` (старт каравана), `f` (финиш), `r` (позиция разбойников). Эти номера переводятся в 0‑индексацию и используются при поисках расстояний.

## Какой алгоритм используется и почему

- Мы используем комбинацию из трёх этапов:
  1. Три BFS (поиск в ширину) для получения кратчайших расстояний от `s`, `f` и `r` до всех вершин (массивы `ds`, `df`, `dr`).
  2. Выделение вершин, которые лежат на хотя бы одном кратчайшем пути от `s` до `f` (условие `ds[v] + df[v] == D`, где `D = ds[f]`). По этим вершинам строим ориентированный ациклический граф, где ребро идёт от уровня `ds` к `ds+1` — т.е. вдоль направлений кратчайшего пути от s к f.
  3. Динамическое программирование по слоям графа (обратный порядок от `f` к `s`) для вычисления оптимального (в смысле каравана) значения: караван выбирает такой кратчайший путь, чтобы минимальное расстояние до разбойников (по всей длине выбранного пути) было максимально возможным.

- Почему так: задача требует учитывать только кратчайшие пути s->f (караван движется только по кратчайшим). Для оценки «насколько близко» разбойники могут подойти к какому‑то выбранному пути мы используем расстояние до ближайшей вершины пути от `r` — минимальное значение `dr` по вершинам пути. Караван хочет максимизировать этот минимум (чтобы быть как можно дальше от разбойников), а разбойники, наоборот, минимизируют расстояние. Поэтому задача становится задачей на выбор пути по критерию maximin.

## Пошаговая работа алгоритма

1. Читаем `n`, `m` и строим список смежности `adj` (0‑индексация).
2. Читаем `s`, `f`, `r` и по ним запускаем три BFS:
   - `ds = bfs(n, adj, s)` — расстояния от `s` до всех вершин.
   - `df = bfs(n, adj, f)` — расстояния от `f`.
   - `dr = bfs(n, adj, r)` — расстояния от `r`.
3. Определяем `D = ds[f]` — длину кратчайшего пути от `s` до `f`.
4. Отбираем вершины, лежащие на хотя бы одном кратчайшем пути `s->f`. Условие: `ds[v] != -1`, `df[v] != -1` и `ds[v] + df[v] == D`.
5. Для отобранных вершин строим ориентированный граф `out`: для ребра (u, v) исходного неориентированного графа добавляем ориентированное ребро `u -> v`, если `ds[v] == ds[u] + 1` и обе вершины на кратчайшем пути. Таким образом образуются слои 0..D, где слой i — вершины на расстоянии i от s.
6. Определяем DP-значение `dp[u]` — максимальное по всем кратчайшим путям, начинающимся в `u`, из минимального значения `dr` вдоль этого пути. Проще: если караван находится в `u` и дальше пойдёт по оптимальному для себя кратчайшему пути до `f`, то `dp[u]` — это расстояние до разбойников до ближайшей вершины на этом оптимальном пути (разбойники же выберут ближайшую к себе вершину на выбранном пути, поэтому рассматриваем минимум dr по вершинам пути; караван выбирает путь, максимизирующий этот минимум).

7. Рекуррент:
   - Для листовой вершины (нет исходящих рёбер в `out`) `dp[u] = dr[u]` (единственный путь — остаться/закончить в u).
   - Иначе для вершины `u`: рассмотрим всех детей `v` в `out[u]`. По пути через `v` минимальное расстояние до r равно `min(dr[u], dp[v])` (потому что ближайшая вершина может быть либо текущая u, либо дальше по пути). Караван выберет того ребёнка `v`, который максимизирует это значение. Значит
     dp[u] = max_{v in out[u]} min(dr[u], dp[v]) = min(dr[u], max_{v in out[u]} dp[v]).

8. Мы вычисляем `dp` по слоям в порядке от D вниз до 0, чтобы значения детей уже были известны.
9. Ответ программы — `dp[s]`.

## Сложность

- Время: три BFS — O(n + m), построение графа и слоёв — O(n + m), обход — O(n + m). Итого O(n + m).

```python
from collections import deque

import sys
  

def bfs(n, adj, start):
	dist = [-1] * n
	dq = deque()
	dist[start] = 0
	dq.append(start)
	while dq:
		u = dq.popleft()
		for v in adj[u]:
			if dist[v] == -1:
				dist[v] = dist[u] + 1
				dq.append(v)
	return dist

  
  

def main():
	line = input().strip()
	while line == '':
		line = input().strip()
	n, m = map(int, line.split())
	adj = [[] for _ in range(n)]
	for _ in range(m):
		a, b = map(int, input().split())
		a -= 1
		b -= 1
		adj[a].append(b)
		adj[b].append(a)
	s, f, r = map(int, input().split())
	s -= 1
	f -= 1
	r -= 1
	
	ds = bfs(n, adj, s)
	df = bfs(n, adj, f)
	dr = bfs(n, adj, r)
	
	D = ds[f]
	
	on_short = [False] * n
	for i in range(n):
		if ds[i] != -1 and df[i] != -1 and ds[i] + df[i] == D:
			on_short[i] = True
	  
	out = [[] for _ in range(n)]
	layers = [[] for _ in range(D + 1)]
	for u in range(n):
		if not on_short[u]:
			continue
		layers[ds[u]].append(u)
		for v in adj[u]:
			if on_short[v] and ds[u] + 1 == ds[v]:
				out[u].append(v)
	dp = [-1] * n
	for layer in range(D, -1, -1):
		for u in layers[layer]:
			if not out[u]:
				dp[u] = dr[u]
			else:
				best = -1
				for v in out[u]:
					if dp[v] > best:
						best = dp[v]
				dp[u] = min(dr[u], best)
	print(dp[s])

if __name__ == '__main__':

main()
```