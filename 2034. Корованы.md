## Основная модель 

- Входные данные дают неориентированный граф: n вершин (поселений) и m рёбер (дороги). Каждое ребро задаётся двумя числами `a b` — между вершинами `a` и `b` есть двунаправленная связь.
- В коде граф хранится как список смежности `adj` длины `n`, где `adj[u]` — список соседей вершины `u` (с учётом сдвига индексов: входные вершины переводятся в 0‑индексацию).
- Также в условии заданы три специальные вершины: `s` (старт каравана), `f` (финиш), `r` (позиция разбойников). Эти номера переводятся в 0‑индексацию и используются при поисках расстояний.

## Какой алгоритм используется и почему

- Мы используем комбинацию из трёх этапов:
  1. Три BFS (поиск в ширину) для получения кратчайших расстояний от `s`, `f` и `r` до всех вершин (массивы `ds`, `df`, `dr`).
  2. Выделение вершин, которые лежат на хотя бы одном кратчайшем пути от `s` до `f` (условие `ds[v] + df[v] == D`, где `D = ds[f]`). По этим вершинам строим ориентированный ациклический граф, где ребро идёт от уровня `ds` к `ds+1` — т.е. вдоль направлений кратчайшего пути от s к f.
  3. Динамическое программирование по слоям графа (обратный порядок от `f` к `s`) для вычисления оптимального (в смысле каравана) значения: караван выбирает такой кратчайший путь, чтобы минимальное расстояние до разбойников (по всей длине выбранного пути) было максимально возможным.

- Почему так: задача требует учитывать только кратчайшие пути s->f (караван движется только по кратчайшим). Для оценки «насколько близко» разбойники могут подойти к какому‑то выбранному пути мы используем расстояние до ближайшей вершины пути от `r` — минимальное значение `dr` по вершинам пути. Караван хочет максимизировать этот минимум (чтобы быть как можно дальше от разбойников), а разбойники, наоборот, минимизируют расстояние. Поэтому задача становится задачей на выбор пути по критерию maximin.

## Пошаговая работа алгоритма

1. Читаем `n`, `m` и строим список смежности `adj` (0‑индексация).
2. Читаем `s`, `f`, `r` и по ним запускаем три BFS:
   - `ds = bfs(n, adj, s)` — расстояния от `s` до всех вершин.
   - `df = bfs(n, adj, f)` — расстояния от `f`.
   - `dr = bfs(n, adj, r)` — расстояния от `r`.
3. Определяем `D = ds[f]` — длину кратчайшего пути от `s` до `f`.
4. Отбираем вершины, лежащие на хотя бы одном кратчайшем пути `s->f`. Условие: `ds[v] != -1`, `df[v] != -1` и `ds[v] + df[v] == D`.
5. Для отобранных вершин строим ориентированный граф `out`: для ребра (u, v) исходного неориентированного графа добавляем ориентированное ребро `u -> v`, если `ds[v] == ds[u] + 1` и обе вершины на кратчайшем пути. Таким образом образуются слои 0..D, где слой i — вершины на расстоянии i от s.
6. Определяем DP-значение `dp[u]` — максимальное по всем кратчайшим путям, начинающимся в `u`, из минимального значения `dr` вдоль этого пути. Проще: если караван находится в `u` и дальше пойдёт по оптимальному для себя кратчайшему пути до `f`, то `dp[u]` — это расстояние до разбойников до ближайшей вершины на этом оптимальном пути (разбойники же выберут ближайшую к себе вершину на выбранном пути, поэтому рассматриваем минимум dr по вершинам пути; караван выбирает путь, максимизирующий этот минимум).

7. Рекуррент:
   - Для листовой вершины (нет исходящих рёбер в `out`) `dp[u] = dr[u]` (единственный путь — остаться/закончить в u).
   - Иначе для вершины `u`: рассмотрим всех детей `v` в `out[u]`. По пути через `v` минимальное расстояние до r равно `min(dr[u], dp[v])` (потому что ближайшая вершина может быть либо текущая u, либо дальше по пути). Караван выберет того ребёнка `v`, который максимизирует это значение. Значит
     dp[u] = max_{v in out[u]} min(dr[u], dp[v]) = min(dr[u], max_{v in out[u]} dp[v]).

8. Мы вычисляем `dp` по слоям в порядке от D вниз до 0, чтобы значения детей уже были известны.
9. Ответ программы — `dp[s]`.

## Сложность

- Время: три BFS — O(n + m), построение графа и слоёв — O(n + m), обход — O(n + m). Итого O(n + m).
